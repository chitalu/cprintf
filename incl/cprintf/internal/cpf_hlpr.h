#ifndef __CPF_HLPR_H__
#define __CPF_HLPR_H__

#include <tuple>
#include <memory>
#include <algorithm>
#include <type_traits>

#include <mutex>

#if !defined(CPF_LINUX_BUILD)
/*
	Note:	GCC does not yet support multi-byte conversion functionality from the following
	header, as a result narrow-string variants of cprintf's API will do nothing until
	this is resolved.
*/
#include <codecvt> //wstring_convert
#endif

#include <cprintf/internal/cpf_scan.h>
#include <cprintf/internal/cpf_carg.h>
#include <cprintf/internal/cpf_tconf.h>

/*
	API compile-time determined runtime flags
*/

// guarrantees atomicity of API call such that no other thread shall 
// execute this function until the current has finished
#define CPF_ATOMIC 0xF

// signifies sequential client program. Note however that none of the API functions 
// are re-entant, as such it is the users' responsibilty to enable atomicity via
// CPF_ATOMIC if using multiple threads in code.
#define CPF_NON 0x0

#define CPF_LOCK_CRITICAL_SECTION {cpf::intern::user_thread_mutex.lock();}

#define CPF_UNLOCK_CRITICAL_SECTION {cpf::intern::user_thread_mutex.unlock();}

namespace cpf
{
	namespace intern
	{
		/*
			on specifiation of CPF_ATOMIC as a template parameter flag to the API, this mutex is used 
			to insure atomicity upon invocation since the API is not re-entrant.  
		*/
		CPF_API std::mutex user_thread_mutex;  

		template <std::size_t...>
		struct indices
		{	 };

		template <	std::size_t Begin,
					std::size_t End,
					typename Indices = indices<>,
					typename Enable = void>
		struct make_seq_indices
		{
			static_assert(Begin <= End, "Begin must be <= End");
		};

		template <	std::size_t Begin,
					std::size_t End,
					template <std::size_t...> class I,
					std::size_t... Indices>
		struct make_seq_indices<Begin,
								End,
								I<Indices...>,
								typename std::enable_if<Begin < End, void>::type>
		{
			using type = typename make_seq_indices<Begin + 1, End, I<Indices..., Begin>>::type;
		};

		template <std::size_t Begin, std::size_t End, typename Indices>
		struct make_seq_indices<Begin,
								End,
								Indices,
								typename std::enable_if<Begin == End, void>::type>
		{
			using type = Indices;
		};

		/*
			to obtain a list of indices.The type alias is defined as :
		*/
		template <std::size_t Begin, std::size_t End>
		using make_seq_indices_T = typename make_seq_indices<Begin, End>::type;

		/*
			It is useful to consider how to pass a set of function arguments to a
			function or functor.The code to do this is:

			**constexpr
		*/
		template <typename Op, typename... Args>
		inline auto apply(Op&& op, Args&&... args) ->
			decltype(std::forward<Op>(op)(std::forward<Args>(args)...))
		{
			return std::forward<Op>(op)(std::forward<Args>(args)...);
		}

		/*
			This function overload applies op to all tuple indices...
		*/
		template <	typename Op,
					typename Tuple,
					template <std::size_t...> class I,
					std::size_t... Indices>
		inline auto _apply_tuple(Op&& op, Tuple&& t, I<Indices...>&&) ->
		decltype(std::forward<Op>(op)(std::get<Indices>(std::forward<Tuple>(t))...))
		{
				return std::forward<Op>(op)(std::get<Indices>(std::forward<Tuple>(t))...);
		}

		/*
			This function overload forwards op and t along with the
			indices of the tuple generated by make_seq_indices...
		*/
		template <	typename Op,
					typename Tuple,
					typename Indices = make_seq_indices_T<	0, std::tuple_size<typename std::decay<Tuple>::type>::value >>
			inline auto apply_tuple(Op&& op, Tuple&& t) ->
			decltype(_apply_tuple(std::forward<Op>(op), std::forward<Tuple>(t), Indices{}))
		{
				return	_apply_tuple(std::forward<Op>(op), std::forward<Tuple>(t), Indices{});
		}

		/*
			convert from narraow character string to wide character string
			@returns wide version of src
		*/
		CPF_API cpf::type::str wconv(const cpf::type::nstr &src);

		/*
			convert from wide character string to narrow character string
			@returns narrow version of src
		*/
		CPF_API cpf::type::nstr nconv(const cpf::type::str &src);

		/*
			@return number of printf argument tokens "%" in a given string
		*/
		CPF_API cpf::type::size get_num_arg_specs(const cpf::type::str & str);

		/*
			print the substring preceding an argument specifier in a sub-format-string
		*/
		CPF_API cpf::type::str write_pre_arg_str(	cpf::type::stream ustream,
													cpf::type::str& printed_string_,
													cpf::type::size& ssp_,
													const cpf::type::attribute_group attr);

		/*
			print the substring proceding an argument specifier in a sub-format-string
		*/
		CPF_API void write_post_arg_str(cpf::type::stream ustream,
										cpf::type::str& printed_string_,
										cpf::type::size& ssp_,
										bool &more_args_on_iter,
										cpf::type::meta::const_iterator &meta_iter,
										const cpf::type::meta::const_iterator &end_point_comparator);

		/*
			print non-argument specifying format string i.e where the implmentation
			need not invoke printf with any avariadic arguments.
		*/
		CPF_API void write_non_arg_str(	cpf::type::stream ustream,
										cpf::type::str& printed_string_,
										cpf::type::size& ssp_,
										cpf::type::meta::const_iterator &meta_iter);

		template<typename T>
		void write_arg(	cpf::type::stream ustream,
						cpf::type::str const &format,
						T&& arg)
		{
			std::fwprintf(ustream, format.c_str(), arg);
		}

		/*
			some tiny extra wizardry has to be done before printing the following types...
		*/
		template<>
		void write_arg<cpf::type::str>(	cpf::type::stream ustream,
										cpf::type::str const &format,
										cpf::type::str&& arg);

		template<>
		void write_arg<cpf::type::nstr>(cpf::type::stream ustream,
										cpf::type::str const &format,
										cpf::type::nstr&& arg);

		template<>
		void write_arg<char*>(	cpf::type::stream ustream,
								cpf::type::str const &format,
								char*&& arg);

		template<>
		void write_arg<signed char*>(	cpf::type::stream ustream,
										cpf::type::str const &format,
										signed char*&& arg);

		template<>
		void write_arg<const char*>(cpf::type::stream ustream,
									cpf::type::str const &format,
									const char*&& arg);

		template<>
		void write_arg<const signed char*>(	cpf::type::stream ustream,
											cpf::type::str const &format,
											const signed char*&& arg);

		/*
			recursion-terminating function (counterpart to "update_ustream" with variadic arguments).
			This is the function executated when the API is called with only a format
			string and no arguments.
		*/
		CPF_API void update_ustream(cpf::type::stream ustream,
									const cpf::type::c_meta_iterator &end_point_comparator,
									cpf::type::c_meta_iterator &meta_iter,
									const cpf::type::str printed_string,
									const cpf::type::size search_start_pos);

		/*
			recursive call to process the format string as well as every argument provided.
			note: this function is not executed if no variadic arguments are respecified.
			using cfprintf_t and cprintf_t guarrantees the execution of this function.
		*/
		template<typename T0, typename ...Ts>
		void update_ustream(cpf::type::stream ustream,
							const cpf::type::c_meta_iterator &end_point_comparator,
							cpf::type::c_meta_iterator &meta_iter,
							const cpf::type::str printed_string,
							const cpf::type::size search_start_pos,
							T0&& arg0,
							Ts&&... args)
		{
			/*
				----------------------------------
				Compile-Time argument verification
				----------------------------------
			*/
			static_assert(
				/*
					check if argument is a char-type pointer (narrow or wide)
				*/
				(	std::is_pointer<T0>::value and
					(	
						std::is_same<wchar_t*, T0>::value			or std::is_same<char*, T0>::value				or
						std::is_same<unsigned char*, T0>::value		or std::is_same<signed char*, T0>::value		or
						std::is_same<const wchar_t*, T0>::value		or std::is_same<const char*, T0>::value			or
						std::is_same<const signed char*, T0>::value	or std::is_same<const unsigned char*, T0>::value
					)
				) or
				/*
					check if argument is of type std::string or std::wstring
				*/
				(
					std::is_same<cpf::type::str, T0>::value or
					std::is_same<cpf::type::nstr, T0>::value
				) or
				/*
					check if argument is of type "float", "double" or "long double"
				*/
				std::is_floating_point<T0>::value or
				/*
					check if argument is of type "char" "short" "int" "long" ("unsigned" included)
				*/
				std::is_integral<T0>::value,
				/*
					------------------------------
					End Of Type-Check Condition...
					------------------------------
				*/
				"CPF-CT-ERR: Illegal argument type");

			cpf::type::str printed_string_ = printed_string;

			/*	
				printed string argument-specifier ('%') count	
			*/
			const auto pstr_argc = cpf::intern::get_num_arg_specs(printed_string_);

			/*
				more variadic args to write using "printed_string_" as
				format string.
			*/
			bool 	more_args_on_iter = false,
					/*
						boolean used to signify whether variadic "arg0" has been
						passed to std::fwprintf as an argument yet
					*/
					printed_arg0 = false;

			/*	
				string parsing start position...	
			*/
			auto ssp_ = search_start_pos;

			if (pstr_argc >= 1)
			{
				auto arg_format_spec = cpf::intern::write_pre_arg_str(ustream,
					printed_string_,
					ssp_,
					meta_iter->second.first);
				/*
					write the current argument i.e. "arg0" as formatted according to "arg_format_spec"
					to the user stream
				*/
				cpf::intern::write_arg(	ustream,
										arg_format_spec,
										std::forward<T0>(arg0));

				cpf::intern::write_post_arg_str(ustream,
												printed_string_,
												ssp_,
												more_args_on_iter,
												meta_iter,
												end_point_comparator);
				printed_arg0 = true;
			}
			else
			{
				cpf::intern::write_non_arg_str(ustream, printed_string_, ssp_, meta_iter);
			}

			bool iter_reached_end = (meta_iter == end_point_comparator);
			auto i_raw_str = iter_reached_end ? L"" : meta_iter->second.second;

			/*
				note: 	only when "arg0" has been passed to std::fwprintf does
						variadic-argument based recursion proceed onto the
						next one subsequently after arg0. Else recurse back
						into this function with the same arguments.
			*/
			if (printed_arg0)
			{
				cpf::intern::update_ustream(ustream, end_point_comparator, meta_iter,
					(!more_args_on_iter && !iter_reached_end) ? i_raw_str : printed_string_,
					more_args_on_iter, std::forward<Ts>(args)...);
			}
			else
			{
				cpf::intern::update_ustream(ustream, end_point_comparator, meta_iter,
					(!more_args_on_iter && !iter_reached_end) ? i_raw_str : printed_string_,
					ssp_, std::forward<T0>(arg0), std::forward<Ts>(args)...);
			}
		}

		template<typename... Ts>
		void dispatch(cpf::type::stream ustream, const cpf::type::str &format, Ts&&... args)
		{
			auto meta_format = cpf::intern::process_format_string(format);

			auto mf_begin = meta_format.cbegin();
			/*
				end point comparator...
				*/
			auto mf_endpoint_cmp = meta_format.cend();

			bool success(true);
			cpf::type::except ex;

			/*
				note:	the try catch block is necessary to restore stream
						state should unexpected behaviour occur at runtime. Typical
						cases are errors in user code.
			*/
			try
			{
				cpf::intern::save_stream_state(ustream);

				/*
					make actual call to do printing and system terminal configurations
				*/
				cpf::intern::update_ustream(ustream,
											mf_endpoint_cmp,
											mf_begin,
											mf_begin->second.second,
											0u,
											std::forward<Ts>(args)...);
			}
			/*runtime error occurred during function execution.*/
			catch (cpf::type::except &e){ ex = e;  success = false; }

			cpf::intern::restore_stream_state(ustream, true);

			if (!success) throw ex;//rethrow!
		}
	}
}

#endif